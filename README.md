# SOLID

S - принцип единой ответственности (single responsibility principle);
O - принцип открытости и закрытости (open/closed principle);
L - принцип подстановки Барбары Лисков (Liskov substitution principle);
I - принцип разделения интерфейса (interface segregation principle);
D - принцип инверсии зависимостей (dependency inversion principle).

## Принцип единой ответственности (Single Responsibility Principle, SRP) 

означает, что у модуля должна быть только одна причина для изменения. Весь код, который меняется по этой причине, должен быть собран в этом модуле.

Проще говоря принцип предлагает нам проводить границы между модулями так, чтобы изменение в бизнес-правилах затрагивало как можно меньше модулей, в идеале — один.

Основной инструмент принципа — объединять те части, которые меняются по одной причине, и разделять те, которые меняются по разным.

### Шаблоны проектирования и приемы рефакторинга

- Выделение класса(прием рефакторинга)
- Фасад (шаблон проетирования)
- Прокси (шаблон проетирования)

### Антипаттерны и запахи

- Боежественный объект
- Синглтон
- Паттерн MVC

## Принцип открытости и закрытости ((Open-Closed Principle, OCP)

Согласно принципу открытости и закрытости модули должны быть открыты для расширения, но закрыты для изменения.

Простыми словами — модули надо проектировать так, чтобы их нельзя было менять, а новая функциональность должна появляться лишь с помощью создания новых сущностей и композиции их со старыми.

Основная цель принципа — помочь разработать проект, устойчивый к изменениям, срок жизни которых превышает срок существования первой версии проекта.

### Шаблоны проектирования и приемы рефакторинга

- Фабрика
- Абстрактная фабрика
- Стратегия
- Декоратор
- Наблюдатель
- Замена прямого наследования на полиморфизм или композицию

### Антипаттерны и запахи

- Связывание через конкретные классы
- Синглтон
- Легковес



## Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP)

Принцип подстановки Барбары Лисков звучит так: функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Простыми словами — классы-наследники не должны противоречить базовому классу. Например, они не могут предоставлять интерфейс ýже базового. Поведение наследников должно быть ожидаемым для функций, которые используют базовый класс.

### Шаблоны проектирования и приёмы рефакторинга

- Контрактное программирование
- Извлечение интерфейса, извлечение суперкласса
- Композиция, изменение модели наследования

### Антипаттерны и запахи

- Непредсказуемое изменение поведения
- Шаблон "Состояние"
- "Пустая" реализация интерфейса



## Принцип разделения интерфейса (Interface Segregation Principle, ISP)

*Сущности не должны зависеть от интерфейсов, которые они не используют*.

Когда принцип нарушается, модули подвержены *всем* изменениям в интерфейсах, от которых они зависят. Это приводит к высокой связанности модулей друг с другом.

ISP помогает проектировать интерфейсы так, чтобы изменения затрагивали только те модули, на функциональность которых они действительно влияют. Чаще всего это заставляет интерфейсы дробить (разделять).

### Шаблоны проектирования и приёмы рефакторинга

- Адаптер
- Выделение интрфейса
- Множественное наследование

### Антипаттерны и запахи

- Грязный интерфейс
- "Пустая" реализация



## Принцип инверсии зависимостей (Dependency Inversion Principle, DIP)

Принцип инверсии зависимостей предполагает, что:

- Высокоуровневые модули не должны зависеть от низкоуровневых; оба типа должны зависеть от абстракций.
- Абстракции не должны зависеть от деталей, детали должны зависеть от абстракций.

Таким образом DIP помогает снизить сцепление модулей (coupling).

### Сцепление и связность

*Сцепление* (coupling) не стоит путать со *связностью* (cohesion).

[Сцепление](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D1%86%D0%B5%D0%BF%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) — степень взаимозависимости разных модулей. Чем выше сцепление, тем более хрупкой получается система, и тем сложнее вносить изменения.

[Связность](https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%8F%D0%B7%D0%BD%D0%BE%D1%81%D1%82%D1%8C_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)) — степень, в которой задачи некоторого модуля, связаны друг с другом. Чем выше связность, тем строже модули следуют SRP, тем выше сфокусирован модуль на конкретной задаче.

### Шаблоны проектирования и приёмы рефакторинга

- Инъекция зависимостей
- Наблюдатель
- Шаблонный метод

### Антипаттерны и запахи

- Контрол-фрик
- Локатор служб



## Источники:

- [SOLID Принципы в JavaScript by Vladilen (YouTube)](https://www.youtube.com/watch?v=xq13wiqvcTc)
- [SOLID](https://ota-solid.now.sh)
- [Ночной фронтенд #33: SOLID — это надёжность](https://soundcloud.com/devschacht/nightly-33)